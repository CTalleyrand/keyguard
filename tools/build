#!/bin/bash

if ! which envsubst > /dev/null 2>&1; then
  echo "You don't seem to have envsubst yet. Go get it! Using sed as an" \
    "alternative approach is to slow... :("
  exit 1
fi

# cleanup
rm -rf dist

# create folder structure
mkdir dist
mkdir dist/request

# bundle files for each request
for DIR in src/request/*/ ; do
    REQUEST=$(basename $DIR)

    echo $REQUEST

    # create directory for request
    mkdir dist/request/$REQUEST

    # get all local js files included in request's index.html
    LIST_JS="$(grep '<script' $DIR/index.html | grep -v -E 'http://|https://' | cut -d\" -f2)"

    # concat them
    for url in $LIST_JS; do
       cat $DIR/$url >> dist/request/$REQUEST/build.js
    done

    # get all css files included in request's index.html
    LIST_CSS="$(grep '<link' $DIR/index.html | cut -d\" -f4)"

    # concat them
    for url in $LIST_CSS; do
       cat $DIR/$url >> dist/request/$REQUEST/build.css
    done

    # replaced scripts and links by bundle in builded index.html
    # and replace CSP strings with ENV variables for configuration
    # XXX: using envsubst as a first suggestion. if it is kept, the one should
    #      make sure to whitelist only known environment variables in there :)
    ENV_TO_REPLACE='' # e.g. '${VAR1} $VAR2'
    awk '
    BEGIN {
      skip_script = 0
      skip_link = 0
    }
    /<script.*https?/ {
      print
      next
    }
    /<script/ {
      if (!skip_script) {
        skip_script = 1
        split($0, space, "<")
        print space[1] "<script defer src=/\"'${REQUEST}'/build.js\"></script>"
      }
      next
    }
    /<link.*https?/ {
      print
      next
    }
    /<link/ {
      if (!skip_link) {
        skip_link = 1
        split($0, space, "<")
        print space[1] "<link rel="stylesheet" href=/\"'${REQUEST}'/build.css\">"
      }
      next
    }
    { print }
    ' $DIR/index.html | envsubst "${ENV_TO_REPLACE}" > dist/request/${REQUEST}/index.html

done
